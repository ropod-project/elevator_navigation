#!/usr/bin/env python
import rospy
import actionlib

from std_msgs.msg import Bool
from geometry_msgs.msg import Pose, PoseStamped, PoseWithCovarianceStamped

from ropod_ros_msgs.srv import GetDoorStatus, GetDoorStatusRequest
from ropod_ros_msgs.msg import Status
from ropod_ros_msgs.msg import GetElevatorWaypointsAction, GetElevatorWaypointsGoal
from ropod_ros_msgs.msg import GetTopologyNodeAction, GetTopologyNodeGoal
from ropod_ros_msgs.msg import NavElevatorAction, NavElevatorFeedback, NavElevatorResult
from floor_detection.srv import DetectFloor, DetectFloorRequest
from map_switcher.srv import SwitchMap, SwitchMapRequest
from maneuver_navigation.msg import Goal as ManeuverNavigationGoal

from pyftsm.ftsm import FTSMStates, FTSMTransitions
from ropod.ftsm.ftsm_base import FTSMBase, DependMonitorTypes

from elevator_navigation.elevator_nav_utils import (ElevatorNavData, has_timed_out, \
                                                    is_waypoint_achieved, send_maneuver_nav_goal,
                                                    get_feedback_msg_skeleton)

class ElevatorNavigation(FTSMBase):
    '''Manages action calls for elevator navigation. The component subscribes to
    four different action types:
    * WAIT_FOR_ELEVATOR
    * ENTER_ELEVATOR
    * RIDE_ELEVATOR
    * EXIT_ELEVATOR

    The actions are exposed through a single action server.

    The component expects several parameters to be made available to the ROS parameter server:
    mn_nav_topic: str -- name of a topic for sending maneuver
                         navigation goals (default /route_navigation/goal)
    mn_nav_cancel_topic: str -- name of a topic for cancelling maneuver
                                navigation goals (default /route_navigation/cancel)
    init_pose_topic: str -- name of a topic for initialising the pose
                            of a robot (default /initialpose)
    localisation_topic: str -- name of a topic on which localisation
                               pose estimates are published (default /amcl_pose)
    elevator_nav_server_name: str -- name of the action server exposed by
                                     the component (default /ropod/take_elevator)
    elevator_waypoints_server: str -- name of an action server that responds to
                                      elevator waypoint queries (default /get_elevator_waypoints)
    topology_node_server: str -- name of a server that responds to queries regarding
                                 area topologies (default /get_topology_node)
    door_status_detection_server: str -- name of a service for checking whether a door
                                         is open or closed (default /get_door_status)
    floor_detection_server: str -- name of a service that returns the currrent floor
                                   of a robot (default /floor_detection_server)
    map_switcher_server: str -- name of a server for loading new environment maps
                                (default /map_switcher/change_map)

    go_to_elevator_timeout: float -- timeout (in seconds) for the action of going to a waypoint
                                     where a robot can wait for an elevator (default 120)
    wait_for_elevator_timeout: float -- timeout (in seconds) for the action of waiting
                                        for an elevator (default 120)
    enter_elevator_timeout: float -- timeout (in seconds) for the action of entering
                                     an elevator (default 120)
    ride_elevator_timeout: float -- timeout (in seconds) for the action of riding
                                    an elevator (default 600)
    exit_elevator_timeout: float -- timeout (in seconds) for the action of exiting
                                    an elevator (default 120)

    pos_tolerance_m: float -- distance tolerance (in meters) for navigation
                              waypoints (default 0.3)
    orientation_tolerance_deg: float -- orientation tolerance (in degrees) for
                                        navigation waypoints (default 20)

    @author Alex Mitrevski, Dharmin Bakaraniya
    @contact aleksandar.mitrevski@h-brs.de

    '''
    mn_nav_pub = None
    init_pose_pub = None
    localisation_sub = None
    get_door_status = None
    get_floor = None
    switch_map = None
    elevator_waypoints_client = None
    topology_node_client = None
    elevator_nav_server = None

    def __init__(self):
        component_name = 'elevator_navigation'
        dependencies = ['roscore', 'world_model_mediator', 'door_status_detector',
                        'floor_detector', 'map_switcher']
        dependency_monitors = {'functional': {'roscore': 'ros/ros_master_monitor',
                                              'world_model_mediator': 'ros/ros_node_monitor',
                                              'door_status_detector': 'ros/ros_node_monitor',
                                              'floor_detector': 'ros/ros_node_monitor',
                                              'map_switcher': 'ros/ros_node_monitor'}}
        super(ElevatorNavigation, self).__init__(component_name,
                                                 dependencies,
                                                 dependency_monitors)

        self.mn_nav_topic = rospy.get_param('~mn_nav_topic', '/route_navigation/goal')
        self.mn_nav_cancel_topic = rospy.get_param('~mn_nav_cancel_topic', '/route_navigation/cancel')
        self.init_pose_topic = rospy.get_param('~init_pose_topic', '/initialpose')
        self.localisation_topic = rospy.get_param('~localisation_topic', '/amcl_pose')

        self.elevator_nav_server_name = rospy.get_param('~elevator_nav_server_name',
                                                        '/ropod/take_elevator')
        self.elevator_waypoints_server = rospy.get_param('~elevator_waypoints_server',
                                                         '/get_elevator_waypoints')
        self.topology_node_server = rospy.get_param('~topology_node_server',
                                                    '/get_topology_node')
        self.door_status_detection_server = rospy.get_param('~door_status_detection_server',
                                                            '/get_door_status')
        self.floor_detection_server = rospy.get_param('~floor_detection_server',
                                                      '/floor_detection_server')
        self.map_switcher_server = rospy.get_param('~map_switcher_server',
                                                   '/map_switcher/change_map')

        self.go_to_elevator_timeout = float(rospy.get_param('~go_to_elevator_timeout', 120.))
        self.wait_for_elevator_timeout = float(rospy.get_param('~wait_for_elevator_timeout', 120.))
        self.enter_elevator_timeout = float(rospy.get_param('~enter_elevator_timeout', 120.))
        self.ride_elevator_timeout = float(rospy.get_param('~ride_elevator_timeout', 600.))
        self.exit_elevator_timeout = float(rospy.get_param('~exit_elevator_timeout', 120.))

        self.pos_tolerance_m = float(rospy.get_param('~pos_tolerance_m', 0.3))
        orientation_tolerance_deg = float(rospy.get_param('~orientation_tolerance_deg', 20.))
        self.orientation_tolerance_rad = (orientation_tolerance_deg * 3.141592) / 180.

        self.elevator_nav_data = ElevatorNavData()

    def init(self):
        try:
            rospy.loginfo('[elevator_nav] Creating a "{0}" topic publisher'.format(self.mn_nav_topic))
            self.mn_nav_pub = rospy.Publisher(self.mn_nav_topic, ManeuverNavigationGoal, queue_size=1)

            rospy.loginfo('[elevator_nav] Creating a "{0}" topic publisher'.format(self.mn_nav_cancel_topic))
            self.mn_nav_cancel_pub = rospy.Publisher(self.mn_nav_cancel_topic, Bool, queue_size=1)

            rospy.loginfo('[elevator_nav] Creating a "{0}" topic publisher'.format(self.init_pose_topic))
            self.init_pose_pub = rospy.Publisher(self.init_pose_topic,
                                                 PoseWithCovarianceStamped,
                                                 queue_size=1)

            rospy.loginfo('[elevator_nav] Creating a "{0}" topic publisher'.format(self.localisation_topic))
            self.localisation_sub = rospy.Subscriber(self.localisation_topic,
                                                     PoseWithCovarianceStamped,
                                                     self.__set_base_pose)


            rospy.loginfo('[elevator_nav] Waiting for "{0}" service'.format(self.door_status_detection_server))
            rospy.wait_for_service(self.door_status_detection_server, timeout=120)

            rospy.loginfo('[elevator_nav] Creating a "{0}" service proxy'.format(self.door_status_detection_server))
            self.get_door_status = rospy.ServiceProxy(self.door_status_detection_server,
                                                             GetDoorStatus)


            rospy.loginfo('[elevator_nav] Waiting for "{0}" service'.format(self.floor_detection_server))
            rospy.wait_for_service(self.floor_detection_server, timeout=120)

            rospy.loginfo('[elevator_nav] Creating a "{0}" service proxy'.format(self.floor_detection_server))
            self.get_floor = rospy.ServiceProxy(self.floor_detection_server, DetectFloor)


            rospy.loginfo('[elevator_nav] Waiting for "{0}" service'.format(self.map_switcher_server))
            rospy.wait_for_service(self.map_switcher_server, timeout=120)

            rospy.loginfo('[elevator_nav] Creating a "{0}" service proxy'.format(self.map_switcher_server))
            self.switch_map = rospy.ServiceProxy(self.map_switcher_server, SwitchMap)


            rospy.loginfo('[elevator_nav] Creating a "{0}" action client'.format(self.elevator_waypoints_server))
            self.elevator_waypoints_client = actionlib.SimpleActionClient(self.elevator_waypoints_server,
                                                                          GetElevatorWaypointsAction)

            rospy.loginfo('[elevator_nav] Waiting for "{0}" action server'.format(self.elevator_waypoints_server))
            self.elevator_waypoints_client.wait_for_server(timeout=rospy.Duration.from_sec(120.))


            rospy.loginfo('[elevator_nav] Creating a "{0}" action client'.format(self.topology_node_server))
            self.topology_node_client = actionlib.SimpleActionClient(self.topology_node_server,
                                                                     GetTopologyNodeAction)

            rospy.loginfo('[elevator_nav] Waiting for "{0}" action server'.format(self.topology_node_server))
            self.topology_node_client.wait_for_server(timeout=rospy.Duration.from_sec(120.))


            rospy.loginfo('[elevator_nav] Creating a "{0}" action server'.format(self.elevator_nav_server_name))
            self.elevator_nav_server = actionlib.SimpleActionServer(self.elevator_nav_server_name,
                                                                    NavElevatorAction,
                                                                    self.get_action, False)
            self.elevator_nav_server.start()
        except rospy.ServiceException as exc:
            rospy.logerr('[elevator_nav] Initialisation error: "{0}"'.format(str(exc)))
            return FTSMTransitions.INIT_FAILED

        return FTSMTransitions.INITIALISED

    def ready(self):
        if not self.elevator_nav_data.current_action:
            return FTSMTransitions.WAIT
        return FTSMTransitions.RUN

    def running(self):
        if not self.elevator_nav_data.current_action:
            return FTSMTransitions.DONE
        return FTSMTransitions.CONTINUE

    def recovering(self):
        return FTSMTransitions.DONE_RECOVERING

    def get_action(self, action_request):
        rospy.loginfo('[elevator_nav] Action request received: "{0}"'.format(action_request.action.type))

        # setting self.elevator_nav_data.current_action
        # allows the FTSM to transition to the running state
        self.elevator_nav_data.current_action = action_request.action
        action_type = self.elevator_nav_data.current_action.type

        # TODO (remove): waiting for a while to give the FTSM time to change the state
        rospy.sleep(0.5)

        current_action_result = None
        try:
            if action_type == 'WAIT_FOR_ELEVATOR':
                current_action_result = self.handle_wait_for_elevator()
            elif action_type == 'ENTER_ELEVATOR':
                current_action_result = self.handle_enter_elevator()
            elif action_type == 'RIDE_ELEVATOR':
                current_action_result = self.handle_ride_elevator()
            elif action_type == 'EXIT_ELEVATOR':
                current_action_result = self.handle_exit_elevator()
            else:
                rospy.logerr('[elevator_nav] Unknown action "{0}" received; ignoring request'.format(action_type))
                current_action_result = NavElevatorResult(success=False)
        except Exception as exc:
            rospy.logerr('[elevator_nav] An error occurred while executing "{0}" action; aborting request'.format(action_type))
            rospy.logerr(str(exc))
            current_action_result = NavElevatorResult(success=False)

        if self.elevator_nav_server.is_preempt_requested():
            self.__cleanup_elevator_nav()
            self.elevator_nav_server.set_preempted()
        else:
            if current_action_result.success:
                self.elevator_nav_server.set_succeeded(current_action_result)
            else:
                self.elevator_nav_server.set_aborted(current_action_result)

        # setting self.elevator_nav_data.current_action to None
        # allows the FTSM to transition to the ready state
        self.elevator_nav_data.current_action = None

    def handle_wait_for_elevator(self):
        feedback_msg = get_feedback_msg_skeleton(self.elevator_nav_data.current_action.action_id,
                                                 self.elevator_nav_data.current_action.type)

        # we get two elevator waypoints - one outside the elevator and one inside
        waiting_pose, inside_pose, door_position = self.get_elevator_waypoints(self.elevator_nav_data.current_action.elevator)
        self.elevator_nav_data.waiting_pose = waiting_pose
        self.elevator_nav_data.inside_elevator_pose = inside_pose
        self.elevator_nav_data.elevator_door_position = door_position
        self.elevator_nav_data.elevator_id = self.elevator_nav_data.current_action.elevator.elevator_id

        # we send a navigation goal to the waypoint outside the elevator and wait
        # for the navigation to complete or time out
        send_maneuver_nav_goal(self.mn_nav_pub, self.elevator_nav_data.base_pose.header.frame_id,
                               self.elevator_nav_data.base_pose.pose.pose,
                               self.elevator_nav_data.waiting_pose)

        start_time = rospy.get_time()
        rospy.loginfo('[elevator_nav] Going to elevator waiting point')
        while not is_waypoint_achieved(self.elevator_nav_data.base_pose.pose.pose,
                                       self.elevator_nav_data.waiting_pose,
                                       self.pos_tolerance_m,
                                       self.orientation_tolerance_rad) and \
              not has_timed_out(start_time, self.go_to_elevator_timeout) and \
              not self.elevator_nav_server.is_preempt_requested():
            feedback_msg.feedback.status.status_code = Status.WAITING
            self.elevator_nav_server.publish_feedback(feedback_msg)
            rospy.sleep(0.5)

        # if the elevator waypoint could not be achieved or the action has been preempted,
        # we give up and return a failure
        if self.elevator_nav_server.is_preempt_requested():
            rospy.logwarn('[elevator_nav] WAIT_FOR_ELEVATOR action preempted')
            return NavElevatorResult(success=False)
        elif not is_waypoint_achieved(self.elevator_nav_data.base_pose.pose.pose,
                                      self.elevator_nav_data.waiting_pose,
                                      self.pos_tolerance_m,
                                      self.orientation_tolerance_rad):
            rospy.logerr('[elevator_nav] Elevator waypoint not achieved within the allotted time; giving up')
            return NavElevatorResult(success=False)

        # we wait for the elevator door to open
        start_time = rospy.get_time()
        rospy.loginfo('[elevator_nav] Waiting for elevator door to open')
        while not self.is_door_open() and \
              not has_timed_out(start_time, self.wait_for_elevator_timeout) and \
              not self.elevator_nav_server.is_preempt_requested():
            feedback_msg.feedback.status.status_code = Status.WAITING
            self.elevator_nav_server.publish_feedback(feedback_msg)
            rospy.sleep(0.5)

        # if the door waiting has timed out or the action has been preempted,
        # we give up and return a failure
        if self.elevator_nav_server.is_preempt_requested():
            rospy.logwarn('[elevator_nav] WAIT_FOR_ELEVATOR action preempted')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_ACTION_PREEMPTED
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)
        elif not self.is_door_open():
            rospy.logerr('[elevator_nav] Elevator door did not open within the allotted time; giving up')
            feedback_msg.feedback.status.status_code = Status.WAITING_FOR_ELEVATOR_FAILED
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)

        feedback_msg.feedback.status.status_code = Status.GOAL_REACHED
        self.elevator_nav_server.publish_feedback(feedback_msg)
        return NavElevatorResult(success=True)

    def handle_enter_elevator(self):
        if self.elevator_nav_data.inside_elevator_pose is None:
            rospy.logerr('[elevator_nav] Cannot execute ENTER_ELEVATOR action since the elevator location is not known (this might indicate a missing WAIT_FOR_ELEVATOR call)')
            return NavElevatorResult(success=False)

        feedback_msg = get_feedback_msg_skeleton(self.elevator_nav_data.current_action.action_id,
                                                 self.elevator_nav_data.current_action.type)

        # we send a navigation goal to the waypoint inside the elevator and wait
        # for the navigation to complete or time out
        send_maneuver_nav_goal(self.mn_nav_pub, self.elevator_nav_data.base_pose.header.frame_id,
                               self.elevator_nav_data.base_pose.pose.pose,
                               self.elevator_nav_data.inside_elevator_pose)

        start_time = rospy.get_time()
        rospy.loginfo('[elevator_nav] Entering elevator')
        while not is_waypoint_achieved(self.elevator_nav_data.base_pose.pose.pose,
                                       self.elevator_nav_data.inside_elevator_pose,
                                       self.pos_tolerance_m,
                                       self.orientation_tolerance_rad) and \
              not has_timed_out(start_time, self.enter_elevator_timeout) and \
              not self.elevator_nav_server.is_preempt_requested():
            feedback_msg.feedback.status.status_code = Status.ENTERING
            self.elevator_nav_server.publish_feedback(feedback_msg)
            rospy.sleep(0.5)

        # if the elevator waypoint could not be achieved or the action has been preempted,
        # we give up and return a failure
        if self.elevator_nav_server.is_preempt_requested():
            rospy.logwarn('[elevator_nav] ENTER_ELEVATOR action preempted')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_ACTION_PREEMPTED
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)
        elif not is_waypoint_achieved(self.elevator_nav_data.base_pose.pose.pose,
                                    self.elevator_nav_data.inside_elevator_pose,
                                    self.pos_tolerance_m,
                                    self.orientation_tolerance_rad):
            rospy.logerr('[elevator_nav] Elevator could not be entered within the allotted time; giving up')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_ENTERING_FAILED
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)

        feedback_msg.feedback.status.status_code = Status.GOAL_REACHED
        self.elevator_nav_server.publish_feedback(feedback_msg)
        return NavElevatorResult(success=True)

    def handle_ride_elevator(self):
        feedback_msg = get_feedback_msg_skeleton(self.elevator_nav_data.current_action.action_id,
                                                 self.elevator_nav_data.current_action.type)

        # we wait for the destination floor to be reached or for the wait to time out
        start_time = rospy.get_time()
        rospy.loginfo('[elevator_nav] Taking elevator to floor {0}'.format(self.elevator_nav_data.current_action.goal_floor))
        while not self.is_destination_floor_reached(self.elevator_nav_data.current_action.goal_floor) and \
                not has_timed_out(start_time, self.ride_elevator_timeout) and \
                not self.elevator_nav_server.is_preempt_requested():
            feedback_msg.feedback.status.status_code = Status.RIDING_ELEVATOR
            self.elevator_nav_server.publish_feedback(feedback_msg)
            rospy.sleep(0.5)

        # if the wait has timed out or the action has been preempted,
        # we give up and return a failure
        if self.elevator_nav_server.is_preempt_requested():
            rospy.logwarn('[elevator_nav] RIDE_ELEVATOR action preempted')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_ACTION_PREEMPTED
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)
        elif not self.is_destination_floor_reached(self.elevator_nav_data.current_action.goal_floor):
            rospy.logerr('[elevator_nav] Elevator ride has not completed within the allotted time; giving up')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_RIDE_TIMEOUT
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)

        # if the destination floor has been reached, we change the map to that of the new floor;
        # we return a failure if the map cannot be switched
        new_map_loaded = self.load_new_map(self.elevator_nav_data.current_action.goal_floor)
        if not new_map_loaded:
            # TODO: retrying to load the map might be a more reasonable option here
            rospy.logerr('[elevator_nav] Could not switch map for new floor; giving up')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_RIDE_MAP_CHANGE_FAILURE
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)

        feedback_msg.feedback.status.status_code = Status.GOAL_REACHED
        self.elevator_nav_server.publish_feedback(feedback_msg)
        return NavElevatorResult(success=True)

    def handle_exit_elevator(self):
        if not self.elevator_nav_data.current_action.areas:
            rospy.logerr('[elevator_nav] Cannot execute EXIT_ELEVATOR action since no exit area is specified')
            return NavElevatorResult(success=False)

        feedback_msg = get_feedback_msg_skeleton(self.elevator_nav_data.current_action.action_id,
                                                 self.elevator_nav_data.current_action.type)

        # we query for a pose of the outside area given in the action message
        outside_area_pose = self.get_outside_area_pose(self.elevator_nav_data.current_action.areas[0].id)

        # we send a navigation goal to the waypoint outside the elevator and wait
        # for the navigation to complete or time out
        send_maneuver_nav_goal(self.mn_nav_pub, self.elevator_nav_data.base_pose.header.frame_id,
                               self.elevator_nav_data.base_pose.pose.pose,
                               outside_area_pose)

        start_time = rospy.get_time()
        rospy.loginfo('[elevator_nav] Exiting elevator')
        while not is_waypoint_achieved(self.elevator_nav_data.base_pose.pose.pose,
                                       outside_area_pose,
                                       self.pos_tolerance_m,
                                       self.orientation_tolerance_rad) and \
              not has_timed_out(start_time, self.exit_elevator_timeout) and \
              not self.elevator_nav_server.is_preempt_requested():
            feedback_msg.feedback.status.status_code = Status.EXITING
            self.elevator_nav_server.publish_feedback(feedback_msg)
            rospy.sleep(0.5)

        # if the outside waypoint could not be achieved, we give up and return a failure
        if self.elevator_nav_server.is_preempt_requested():
            rospy.logwarn('[elevator_nav] EXIT_ELEVATOR action preempted')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_ACTION_PREEMPTED
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)
        elif not is_waypoint_achieved(self.elevator_nav_data.base_pose.pose.pose,
                                    outside_area_pose,
                                    self.pos_tolerance_m,
                                    self.orientation_tolerance_rad):
            rospy.logerr('[elevator_nav] Elevator could not be exited within the allotted time; giving up')
            feedback_msg.feedback.status.status_code = Status.ELEVATOR_EXITING_FAILED
            self.elevator_nav_server.publish_feedback(feedback_msg)
            return NavElevatorResult(success=False)

        feedback_msg.feedback.status.status_code = Status.GOAL_REACHED
        self.elevator_nav_server.publish_feedback(feedback_msg)
        return NavElevatorResult(success=True)

    def get_elevator_waypoints(self, elevator_params):
        '''Returns a tuple of three elements:
        * waiting_pose: geometry_msgs.msg.Pose -- a pose where a robot should wait for an elevator
        * inside_elevator_pose: geometry_msgs.msg.Pose -- a pose inside an elevator
        * elevator_door_position: geometry_msgs.msg.Pose -- position of an elevator door

        The first two of these are obtained by sending a query to self.elevator_waypoints_client;
        the elevator door position is obtained by querying self.topology_node_client.

        Raises a generic exception if either of the queries fails.

        '''
        waiting_pose = None
        inside_elevator_pose = None
        elevator_door_position = None

        elevator_waypoints_goal = GetElevatorWaypointsGoal()
        elevator_waypoints_goal.elevator_id = elevator_params.elevator_id
        elevator_waypoints_goal.door_id = elevator_params.door_id

        rospy.loginfo('[elevator_nav] Querying for elevator waypoints')
        self.elevator_waypoints_client.send_goal(elevator_waypoints_goal)
        if self.elevator_waypoints_client.wait_for_result(rospy.Duration.from_sec(10)):
            elevator_waypoint_result = self.elevator_waypoints_client.get_result()
            waiting_pose = elevator_waypoint_result.wp_outside
            inside_elevator_pose = elevator_waypoint_result.wp_inside
            rospy.loginfo('Waypoints for elevator {0} and door {1} retrieved'.format(elevator_params.elevator_id,
                                                                                     elevator_params.door_id))
        else:
            rospy.logerr('Waypoints for elevator {0} and door {1} could not be retrieved'.format(elevator_params.elevator_id,
                                                                                                 elevator_params.door_id))
            raise Exception('Elevator waypoints could not be retrieved')

        topology_node_goal = GetTopologyNodeGoal()
        topology_node_goal.id = elevator_params.door_id
        topology_node_goal.type = 'door'

        rospy.loginfo('[elevator_nav] Querying for elevator door position')
        self.topology_node_client.send_goal(topology_node_goal)
        if self.topology_node_client.wait_for_result(rospy.Duration.from_sec(10.)):
            topology_client_result = self.topology_node_client.get_result()
            elevator_door_position = topology_client_result.position
        else:
            rospy.logerr('Topology information for door {0} could not be retrieved'.format(elevator_params.door_id))
            raise Exception('Door topology information could not be retrieved')

        return (waiting_pose, inside_elevator_pose, elevator_door_position)

    def get_outside_area_pose(self, outside_area_id):
        '''Calls self.topology_node_client to obtain the position of the given area
        and returns a geometry_msgs.msg.Pose object representing the area pose
        (with the obtained position and orientation = (0, 0, 0)).
        Raises a generic exception if the call to self.topology_node_client is not successful.

        Keyword argument:
        outside_area_id: str -- ID of an area outside the elevator

        '''
        topology_node_goal = GetTopologyNodeGoal()
        topology_node_goal.id = int(outside_area_id)
        topology_node_goal.type = 'local_area'

        self.topology_node_client.send_goal(topology_node_goal)
        topology_client_completed = self.topology_node_client.wait_for_result(rospy.Duration.from_sec(10.))
        if topology_client_completed:
            topology_client_result = self.topology_node_client.get_result()

            outside_area_pose = Pose()
            outside_position = topology_client_result.position

            outside_area_pose.position.x = outside_position.x
            outside_area_pose.position.y = outside_position.y
            outside_area_pose.position.z = 0.

            # TODO: handle the orientation better (e.g. what if we have a cart and we cannot easily get out)
            outside_area_pose.orientation.x = 0.
            outside_area_pose.orientation.y = 0.
            outside_area_pose.orientation.z = 0.
            outside_area_pose.orientation.w = 1.
            return outside_area_pose
        else:
            rospy.logerr('Topology information for area "{0}" could not be retrieved'.format(outside_area_id))
            raise Exception('Area topology information could not be retrieved')

    def is_door_open(self):
        '''Calls self.get_door_status and returns the current door status.
        Raises a rospy.ServiceException exception if there is a service call error.
        '''
        door_status_request = GetDoorStatusRequest()
        door_status_request.robot_pose = self.elevator_nav_data.base_pose.pose.pose
        door_status_request.door_position = self.elevator_nav_data.elevator_door_position

        try:
            door_status_response = self.get_door_status(door_status_request)
            if door_status_response.status:
                return True
            else:
                return False
        except rospy.ServiceException as exc:
            rospy.logerr('[elevator_nav] Could not check the door status')
            raise

    def is_destination_floor_reached(self, destination_floor):
        '''Calls self.get_floor and returns True if the current floor as obtained
        from the service call equals the destination floor; returns False otherwise.
        Raises a rospy.ServiceException exception if there is a service call error.

        Keyword arguments:
        destination_floor: int -- destination floor for the elevator ride

        '''
        try:
            get_floor_request = DetectFloorRequest()
            get_floor_response = self.get_floor(get_floor_request)
            if get_floor_response.floor == destination_floor:
                rospy.loginfo('[elevator_nav] Reached floor {0}'.format(destination_floor))
                return True
            return False
        except rospy.ServiceException as exc:
            rospy.logerr('[elevator_nav] Could not get the current floor: {0}'.format(str(exc)))
            raise

    def load_new_map(self, destination_floor):
        '''Calls self.switch_map to load a map of the current floor and relocalises
        the robot in the new map.

        Note: Map names are assumed to follow the naming convention "map_floor<x>",
        where <x> is the floor number. In the call to self.switch_map, wormholes
        are assumed to follow the naming convention "elevator_<y>", where <y>
        is an elevator ID.

        Keyword arguments:
        destination_floor: int -- destination floor for the elevator ride

        '''
        try:
            switch_map_request = SwitchMapRequest()
            switch_map_request.entry_wormhole = 'elevator_' + str(self.elevator_nav_data.elevator_id)
            switch_map_request.new_map = 'map_floor' + str(destination_floor)

            rospy.loginfo('[elevator_nav] Switching map to {0}'.format(switch_map_request.new_map))
            switch_map_response = self.switch_map(switch_map_request)
            if switch_map_response.success:
                rospy.loginfo('[elevator_nav] Map switched reinitialising localisation')
                current_pose = PoseWithCovarianceStamped()
                current_pose.header.frame_id = self.elevator_nav_data.base_pose.header.frame_id
                current_pose.pose.pose = self.elevator_nav_data.base_pose.pose.pose
                self.init_pose_pub.publish(current_pose)
                rospy.loginfo('[elevator_nav] Localisation reinitialised')
                return True
            else:
                rospy.logerr('[elevator_nav] Could not switch map to {0}'.format(switch_map_request.new_map))
                return False
        except rospy.ServiceException as exc:
            rospy.logerr('[elevator_nav] Could not switch map: {0}'.format(str(exc)))
            raise

    def __set_base_pose(self, pose_msg):
        '''Sets self.elevator_nav_data.base_pose to the given argument.

        Keyword arguments:
        pose_msg: geometry_msgs.msg.PoseWithCovarianceStamped

        '''
        self.elevator_nav_data.base_pose = pose_msg

    def __cleanup_elevator_nav(self):
        '''Cancels any ongoing navigation goals.
        '''
        cancel_nav_msg = Bool()
        cancel_nav_msg.data = True
        self.mn_nav_cancel_pub.publish(cancel_nav_msg)

    def __reset_elevator_nav(self):
        '''Resets self.elevator_nav_data.
        '''
        self.elevator_nav_data = ElevatorNavData()

if __name__ == '__main__':
    rospy.init_node('elevator_navigation')
    elevator_navigation_node = ElevatorNavigation()
    try:
        elevator_navigation_node.run()
        while elevator_navigation_node.is_running and not rospy.is_shutdown():
            rospy.sleep(0.1)
    except (KeyboardInterrupt, SystemExit):
        rospy.loginfo('{0} interrupted exiting...'.format(elevator_navigation_node.name))
        elevator_navigation_node.stop()
